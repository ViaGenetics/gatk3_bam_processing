#!/usr/bin/env python
# gatk3_bam_processing 0.0.1
# Generated by dx-app-wizard.
#
# Basic execution pattern: Your app will run on a single machine from
# beginning to end.
#
# See https://wiki.dnanexus.com/Developer-Portal for documentation and
# tutorials on how to modify this file.
#
# DNAnexus Python Bindings (dxpy) documentation:
#   http://autodoc.dnanexus.com/bindings/python/current/

import os
import dxpy
import logging
import time


logger = logging.getLogger(__name__)
logger.addHandler(dxpy.DXLogHandler())
logger.propagate = False


try:
    from dx_applet_utilities import (
        common_job_operations as dx_utils,
        manage_command_execution as dx_exec,
        prepare_job_resources as dx_resources)
except ImportError:
    logger.error("Make sure to add the dx_applet_utilities to execDepends in dxapp.json!")
    sys.exit(1)


@dxpy.entry_point("main")
def main(bam_files, sampleId, padding, reference, loglevel, regions_file=None,
    indel_vcf=None, dbsnp=None, advanced_rtc_options=None,
    advanced_ir_options=None, advanced_br_options=None, advanced_pr_options=None):

    """This is a dx applet that runs on the DNAnexus platform.

    :param: `bam_files`:
    :param: `sampleId`:
    :param: `padding`:
    :param: `reference`:
    :param: `loglevel`:
    :param: `regions_file`:
    :param: `indel_vcf`:
    :param: `dbsnp`:
    :param: `loglevel`:
    :param: `advanced_rtc_options`:
    :param: `advanced_ir_options`:
    :param: `advanced_br_options`:
    :param: `advanced_pr_options`:
    :returns: This will return an dx object with output generated. This is
        actually taken care of by dxpy client libraries.
    """

    # Set up string variables that are not required

    if not advanced_rtc_options:
        advanced_rtc_options = ""

    if not advanced_ir_options:
        advanced_ir_options = ""

    if not advanced_br_options:
        advanced_br_options = ""

    if not advanced_pr_options:
        advanced_pr_options = ""

    # Set up execution environment

    logger.setLevel(loglevel)
    cpus = dx_resources.number_of_cpus(1.0)
    max_ram = dx_resources.max_memory(0.85)
    logger.info("# of CPUs:{0}\nMax RAM:{1}".format(cpus, max_ram))

    temp_directories = [
        "genome/",
        "out/output_recalibrated_bam/",
        "out/output_recalibrated_cram/,
        "tmp/preprocessing/",
        "tmp/realignment/",
        "tmp/recalibration/"
    ]

    for temp_directory in temp_directories:
        create_dir = dx_exec.execute_command("mkdir -p {0}".format(
            temp_directory))
        dx_exec.check_execution_syscode(create_dir, "Created: {0}".format(
            temp_directory))
        chmod_dir = dx_exec.execute_command("chmod 777 -R {0}".format(
            temp_directory))
        dx_exec.check_execution_syscode(chmod_dir, "Modified: {0}".format(
            temp_directory))

    # The following line(s) initialize your data object inputs on the platform
    # into dxpy.DXDataObject instances that you can start using immediately.

    reference_filename = "in/reference/{0}".format(
        dxpy.DXFile(reference).describe()["name"])
    reference_index_filename = "in/reference_index/{0}".format(
        dxpy.DXFile(reference_index).describe()["name"])

    bam_filenames = []
    for index, bam_file in enumerate(bam_files):

        # DNAnexus has this funky behavior when you have > 9 files, it creates
        # a folder in/parameter/08/file - this resolves that issue
        if len(bam_files) > 9 and index < 10:
            index = "0{0}".format(index)

        bam_filenames.append("in/bam_files/{0}/{1}".format(index,
            dxpy.DXFile(bam_file).describe()['name']))

    indel_vcf_files = []
    known_parameter = ""
    knownsites_parameter = ""
    if indel_vcf:
        for index, file_object in enumerate(indel_vcf):
            filename = "in/indel_vcf/{0}/{1}".format(index,
                dxpy.DXFile(file_object).describe()['name'])
            indel_vcf_files.append(filename)
            known_parameter += "-known {0} ".format(filename)
            knownsites_parameter += "-knownSites {0} ".format(filename)

    dbsnp_parameter = ""
    if dbsnp:
        dbsnp = "in/dbsnp/{0}".format(dxpy.DXFile(dbsnp).describe()['name'])
        dbsnp_parameter = "--dbsnp {0} ".format(dbsnp)
        knownsites_parameter += "-knownSites {0} ".format(dbsnp)

    regions_parameter = ""
    if regions_file:
        regions_file = "in/regions_file/{0}".format(
            dxpy.DXFile(regions_file).describe()['name'])
        regions_parameter = "-L {0} ".format(regions_file)

        if padding:
            regions_parameter += "-ip {0} ".format(padding)


    # The following line(s) download your file inputs to the local file system
    # using variable names for the filenames.

    dx_download_inputs_cmd = "dx-download-all-inputs --parallel"
    download_inputs = dx_exec.execute_command(dx_download_inputs_cmd)
    dx_exec.check_execution_syscode(download_inputs, "Download input files")

    # The following line(s) are the body of the applet that
    # executes the bioinformatics processes

    # Prepare refernce genome for GATK

    unzip_reference_genome_cmd = "gzip -dc {0} > genome/genome.fa".format(
        reference_filename)
    reference_filename = "genome/genome.fa"

    reference_faidx_cmd = "samtools faidx {0}".format(reference_filename)
    reference_faidx = dx_exec.execute_command(reference_faidx_cmd)
    dx_exec.check_execution_syscode(reference_faidx, "Reference samtools faidx")

    reference_dict = "genome/genome.dict"
    reference_dict_cmd = "samtools dict {0} > {1}".format(reference_filename, reference_dict)
    reference_dict = dx_exec.execute_command(reference_dict_cmd)
    dx_exec.check_execution_syscode(reference_dict, "Reference samtools dict")

    # Index VCFs for GATK using tabix

    if dbsnp:
        dbsnp_tabix_cmd = "tabix -p vcf {0}".format(dbsnp)
        dbsnp_tabix = dx_exec.execute_command(dbsnp_tabix_cmd)
        dx_exec.check_execution_syscode(dbsnp_tabix, "Tabix of dbSNP VCF")

    if indel_vcf:
        for vcf_file in indel_vcf_files:
            indel_vcf_tabix_cmd = "tabix -p vcf {0}".format(vcf_file)
            indel_vcf_tabix = dx_exec.execute_command(indel_vcf_tabix_cmd)
            dx_exec.check_execution_syscode(indel_vcf_tabix, "Tabix of {0}".format(vcf_file))

    # Merge BAM files if there are more than one
    if len(bam_filenames) > 1:
        merged_bam = "tmp/preprocessing/merged.bam"
        merge_bam_cmd = "sambamba merge -t {0} {1} {2}".format(
            cpus, merged_bam, " ".join(bam_filenames))
        merge_bam = dx_exec.execute_command(merge_bam_cmd)
        dx_exec.check_execution_syscode(merge_bam)

        sorted_bam = "tmp/preprocessing/sorted.bam"
        sort_bam_cmd = "sambamba sort -t {0} {1} -o {2}".format(
            cpus, merged_bam, sorted_bam)
        sort_bam = dx_exec.execute_command(sort_bam_cmd)
        dx_exec.check_execution_syscode(sort_bam)

        # Rename bam_files to the new sorted BAM file. This is what will be used for GATK processing
        bam_filenames = [sorted_bam]

    # GATK in/del realignment phase

    # 1. RealignerTargetCreator

    rtc_input = bam_filenames[0]
    rtc_output = "tmp/realignment/realign.intervals"

    rtc_cmd = "java -Xmx{0}m -jar /opt/jar/GenomeAnalysisTK.jar ".format(max_ram)
    rtc_cmd += "-T RealignerTargetCreator {0} -nt {2} ".format(
        advanced_rtc_options, cpus)
    rtc_cmd += " -R {0} {1} {2} -I {3} -o {4}".format(
        reference, known_parameter, regions_parameter, rtc_input, rtc_output)

    # Need to index BAM file for GATK
    idx_rtc_input_cmd = "sambamba index -p -t {0} {1}".format(cpus, rtc_input)
    idx_rtc_input = dx_exec.execute_command(idx_rtc_input_cmd)
    dx_exec.check_execution_syscode(idx_rtc_input)

    gatk_rtc = dx_exec.execute_command(rtc_cmd)
    dx_exec.check_execution_syscode(gatk_rtc)

    # 2. IndelRealigner

    ir_input = bam_filenames[0]
    ir_output = "tmp/realignment/realigned.bam"

    ir_cmd = "java -Xmx{0}m -jar /opt/jar/GenomeAnalysisTK.jar ".format(max_ram)
    ir_cmd += "-T IndelRealigner {0} -R {1} ".format(advanced_ir_options, reference)
    ir_cmd += "-targetIntervals {0} {1} -I {2} -o {3}".format(rtc_output,
        known_parameter, ir_input, ir_output)

    gatk_ir = dx_exec.execute_command(ir_cmd)
    dx_exec.check_execution_syscode(gatk_ir)

    # The following line(s) use the Python bindings to upload your file outputs
    # after you have created them on the local file system.  It assumes that you
    # have used the output field name for the filename for each output, but you
    # can change that behavior to suit your needs.

    output_recalibrated_bam = dxpy.upload_local_file("output_recalibrated_bam")
    output_recalibrated_cram = dxpy.upload_local_file("output_recalibrated_cram")

    # The following line fills in some basic dummy output and assumes
    # that you have created variables to represent your output with
    # the same name as your output fields.

    output = {}
    output["output_recalibrated_bam"] = dxpy.dxlink(output_recalibrated_bam)
    output["output_recalibrated_cram"] = dxpy.dxlink(output_recalibrated_cram)

    return output

dxpy.run()
