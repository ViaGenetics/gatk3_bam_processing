#!/usr/bin/env python
# gatk3_bam_processing 0.0.1
# Generated by dx-app-wizard.
#
# Basic execution pattern: Your app will run on a single machine from
# beginning to end.
#
# See https://wiki.dnanexus.com/Developer-Portal for documentation and
# tutorials on how to modify this file.
#
# DNAnexus Python Bindings (dxpy) documentation:
#   http://autodoc.dnanexus.com/bindings/python/current/

import os
import dxpy
import logging
import time


logger = logging.getLogger(__name__)
logger.addHandler(dxpy.DXLogHandler())
logger.propagate = False


try:
    from dx_applet_utilities import (
        common_job_operations as dx_utils,
        manage_command_execution as dx_exec,
        prepare_job_resources as dx_resources)
except ImportError:
    logger.error("Make sure to add the dx_applet_utilities to execDepends in dxapp.json!")
    sys.exit(1)


@dxpy.entry_point("main")
def main(bam_files, sampleId, padding, reference, loglevel, regions_file=None,
    indel_vcf=None, dbsnp=None, advanced_rtc_options=None,
    advanced_ir_options=None, advanced_br_options=None, advanced_pr_options=None):

    """This is a dx applet that runs on the DNAnexus platform.

    :param: `bam_files`:
    :param: `sampleId`:
    :param: `padding`:
    :param: `reference`:
    :param: `loglevel`:
    :param: `regions_file`:
    :param: `indel_vcf`:
    :param: `dbsnp`:
    :param: `loglevel`:
    :param: `advanced_rtc_options`:
    :param: `advanced_ir_options`:
    :param: `advanced_br_options`:
    :param: `advanced_pr_options`:
    :returns: This will return an dx object with output generated. This is
        actually taken care of by dxpy client libraries.
    """

    # Set up string variables that are not required

    if not advanced_rtc_options:
        advanced_rtc_options = ""

    if not advanced_ir_options:
        advanced_ir_options = ""

    if not advanced_br_options:
        advanced_br_options = ""

    if not advanced_pr_options:
        advanced_pr_options = ""

    # Set up execution environment

    logger.setLevel(loglevel)
    cpus = dx_resources.number_of_cpus(1.0)
    max_ram = dx_resources.max_memory(0.85)
    logger.info("# of CPUs:{0}\nMax RAM:{1}".format(cpus, max_ram))

    temp_directories = [
        "genome/",
        "out/output_recalibrated_bam/",
        "out/output_recalibrated_cram/,
        "tmp/preprocessing/",
        "tmp/realignment/",
        "tmp/recalibration/"
    ]

    for temp_directory in temp_directories:
        create_dir = dx_exec.execute_command("mkdir -p {0}".format(
            temp_directory))
        dx_exec.check_execution_syscode(create_dir, "Created: {0}".format(
            temp_directory))
        chmod_dir = dx_exec.execute_command("chmod 777 -R {0}".format(
            temp_directory))
        dx_exec.check_execution_syscode(chmod_dir, "Modified: {0}".format(
            temp_directory))

    # The following line(s) initialize your data object inputs on the platform
    # into dxpy.DXDataObject instances that you can start using immediately.

    reference_filename = "in/reference/{0}".format(
        dxpy.DXFile(reference).describe()["name"])
    reference_index_filename = "in/reference_index/{0}".format(
        dxpy.DXFile(reference_index).describe()["name"])

    bam_filenames = []
    for index, bam_file in enumerate(bam_files):

        # DNAnexus has this funky behavior when you have > 9 files, it creates
        # a folder in/parameter/08/file - this resolves that issue
        if len(bam_files) > 9 and index < 10:
            index = "0{0}".format(index)

        bam_filenames.append("in/bam_files/{0}/{1}".format(index,
            dxpy.DXFile(bam_file).describe()['name']))

    indel_vcf_files = []
    known_parameter = ""
    knownsites_parameter = ""
    if indel_vcf:
        for index, file_object in enumerate(indel_vcf):
            filename = "in/indel_vcf/{0}/{1}".format(index,
                dxpy.DXFile(file_object).describe()['name'])
            indel_vcf_files.append(filename)
            known_parameter += "-known {0} ".format(filename)
            knownsites_parameter += "-knownSites {0} ".format(filename)

    dbsnp_parameter = ""
    if dbsnp:
        dbsnp = "in/dbsnp/{0}".format(dxpy.DXFile(dbsnp).describe()['name'])
        dbsnp_parameter = "--dbsnp {0} ".format(dbsnp)
        knownsites_parameter += "-knownSites {0} ".format(dbsnp)

    regions_parameter = ""
    if regions_file:
        regions_file = "in/regions_file/{0}".format(
            dxpy.DXFile(regions_file).describe()['name'])
        regions_parameter = "-L {0} ".format(regions_file)

        if padding:
            regions_parameter += "-ip {0} ".format(padding)


    # The following line(s) download your file inputs to the local file system
    # using variable names for the filenames.

    dx_download_inputs_cmd = "dx-download-all-inputs --parallel"
    download_inputs = dx_exec.execute_command(dx_download_inputs_cmd)
    dx_exec.check_execution_syscode(download_inputs, "Download input files")

    # Fill in your application code here.

    # The following line(s) use the Python bindings to upload your file outputs
    # after you have created them on the local file system.  It assumes that you
    # have used the output field name for the filename for each output, but you
    # can change that behavior to suit your needs.

    output_recalibrated_bam = dxpy.upload_local_file("output_recalibrated_bam")
    output_recalibrated_cram = dxpy.upload_local_file("output_recalibrated_cram")

    # The following line fills in some basic dummy output and assumes
    # that you have created variables to represent your output with
    # the same name as your output fields.

    output = {}
    output["output_recalibrated_bam"] = dxpy.dxlink(output_recalibrated_bam)
    output["output_recalibrated_cram"] = dxpy.dxlink(output_recalibrated_cram)

    return output

dxpy.run()
